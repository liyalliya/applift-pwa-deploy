<!DOCTYPE html>
<html>
<head>
  <title>AppLift IMU Monitor - Sliding Window Rep Counter</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background-color: #f5f5f5; }
    button { padding: 10px 20px; font-size: 16px; margin-bottom: 20px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }
    button:hover { background-color: #0056b3; }
    .container { max-width: 1400px; margin: 0 auto; }
    .data-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px; }
    .data-card { background: white; border: 1px solid #ddd; padding: 15px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    .data-card h3 { margin-top: 0; color: #333; font-size: 16px; }
    .value { font-size: 24px; font-weight: bold; color: #007bff; }
    .rep-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
    .rep-card .value { color: white; font-size: 48px; }
    .chart-container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; }
    .status { padding: 5px 10px; border-radius: 4px; font-size: 14px; font-weight: bold; display: inline-block; margin-top: 10px; }
    .status.detecting { background-color: #28a745; color: white; }
    .status.idle { background-color: #6c757d; color: white; }
    .controls { margin-bottom: 20px; }
    .controls button { margin-right: 10px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üèãÔ∏è AppLift IMU Monitor - Sliding Window Rep Counter</h1>
    
    <div class="controls">
      <button onclick="connectToBLE()">Connect to Device</button>
      <button onclick="resetRepCount()">Reset Rep Count</button>
      <button onclick="toggleRecording()">Start Recording</button>
      <span style="margin-left: 20px; color: #28a745; font-weight: bold;">
        ‚ö° FAST RESPONSE - 1.5s window, auto-reset
      </span>
    </div>
    
    <div class="data-grid">
      <div class="data-card rep-card">
        <h3>Rep Count</h3>
        <p class="value" id="rep-count">0</p>
        <p>Current Set</p>
        <div class="status idle" id="rep-status">Idle</div>
      </div>
      
      <div class="data-card">
        <h3>Accelerometer (Raw)</h3>
        <p>X: <span class="value" id="accel-x">--</span> m/s¬≤</p>
        <p>Y: <span class="value" id="accel-y">--</span> m/s¬≤</p>
        <p>Z: <span class="value" id="accel-z">--</span> m/s¬≤</p>
        <p>Mag: <span class="value" id="accel-mag">--</span> m/s¬≤</p>
      </div>
      
      <div class="data-card">
        <h3>Accelerometer (Filtered)</h3>
        <p>X: <span class="value" id="accel-x-filtered">--</span> m/s¬≤</p>
        <p>Y: <span class="value" id="accel-y-filtered">--</span> m/s¬≤</p>
        <p>Z: <span class="value" id="accel-z-filtered">--</span> m/s¬≤</p>
        <p>Mag: <span class="value" id="accel-mag-filtered">--</span> m/s¬≤</p>
      </div>
      
      <div class="data-card">
        <h3>Gyroscope</h3>
        <p>X: <span class="value" id="gyro-x">--</span> rad/s</p>
        <p>Y: <span class="value" id="gyro-y">--</span> rad/s</p>
        <p>Z: <span class="value" id="gyro-z">--</span> rad/s</p>
      </div>
    </div>
    
    <div class="chart-container">
      <h3>Real-time Acceleration Data</h3>
      <canvas id="accelChart"></canvas>
    </div>
    
    <div class="data-grid">
      <div class="data-card">
        <h3>Orientation</h3>
        <p>Roll: <span class="value" id="roll">--</span>¬∞</p>
        <p>Pitch: <span class="value" id="pitch">--</span>¬∞</p>
        <p>Yaw: <span class="value" id="yaw">--</span>¬∞</p>
      </div>
      
      <div class="data-card">
        <h3>Rep Detection (Sliding Window)</h3>
        <p>State: <span class="value" id="rep-state">--</span></p>
        <p>Buffer: <span class="value" id="buffer-state">--</span></p>
        <p>RepHeight: <span class="value" id="last-peak">--</span></p>
      </div>
      
      <div class="data-card">
        <h3>Dynamic Thresholds</h3>
        <p>High: <span class="value" id="threshold-high-display">--</span></p>
        <p>Low: <span class="value" id="threshold-low-display">--</span></p>
        <p>Range: <span class="value" id="threshold-range">--</span></p>
      </div>
      
      <div class="data-card">
        <h3>Algorithm Settings</h3>
        <p style="font-size: 12px;">Window: <span class="value" style="font-size: 14px;">1.5s</span> (80% overlap)</p>
        <p style="font-size: 12px;">Min Duration: <span class="value" style="font-size: 14px;">0.5s</span></p>
        <p style="font-size: 12px;">Prominence: <span class="value" style="font-size: 14px;">0.08</span> m/s¬≤</p>
        <p style="font-size: 11px; color: #666; margin-top: 5px;">‚ö° FAST RESPONSE - Auto-reset window</p>
      </div>
      
      <div class="data-card">
        <h3>Statistics</h3>
        <p>Avg Time: <span class="value" id="avg-rep-time">--</span>s</p>
        <p>Last Rep: <span class="value" id="last-rep-time">--</span>s</p>
        <p>Total Time: <span class="value" id="total-time">--</span>s</p>
      </div>
      
      <div class="data-card">
        <h3>Connection</h3>
        <p>Status: <span class="value" id="connection-status">Disconnected</span></p>
        <p>Samples: <span class="value" id="sample-count">0</span></p>
        <p>Data Rate: <span class="value" id="data-rate">0</span> Hz</p>
      </div>
      
      <div class="data-card">
        <h3>üì± NFC Equipment</h3>
        <p>Current: <span class="value" id="nfc-equipment">None</span></p>
        <p>Last Scan: <span class="value" id="nfc-timestamp">--</span></p>
        <p style="font-size: 12px; color: #666; margin-top: 5px;">Equipment detected via NFC scan</p>
      </div>
  </div>

  <script>
    const SERVICE_UUID = '4fafc201-1fb5-459e-8fcc-c5c9c331914b';
    const CHARACTERISTIC_UUID_IMU = 'beb5483e-36e1-4688-b7f5-ea07361b26a8';

    let device = null;
    let characteristic = null;
    let chart = null;
    let isRecording = false;
    let recordingStartTime = 0;
    let countdownActive = false;
    
    // Raw data logging for CSV export
    let rawDataLog = [];
    
    // Data buffers
    const MAX_CHART_POINTS = 100; // Show last 5 seconds at 20Hz
    const timeData = [];
    const accelMagData = [];
    const accelMagFilteredData = [];
    
    // Kalman Filter for each axis
    class KalmanFilter {
      constructor(processNoise = 0.01, measurementNoise = 0.25, estimationError = 1, initialValue = 0) {
        this.processNoise = processNoise;          // Q - Process noise covariance
        this.measurementNoise = measurementNoise;  // R - Measurement noise covariance
        this.estimationError = estimationError;    // P - Estimation error covariance
        this.value = initialValue;                 // X - Estimated value
      }
      
      update(measurement) {
        // Prediction update
        this.estimationError += this.processNoise;
        
        // Measurement update
        const kalmanGain = this.estimationError / (this.estimationError + this.measurementNoise);
        this.value += kalmanGain * (measurement - this.value);
        this.estimationError = (1 - kalmanGain) * this.estimationError;
        
        return this.value;
      }
    }
    
    // Create Kalman filters for each axis
    const kalmanX = new KalmanFilter(0.01, 0.5, 1, 0);
    const kalmanY = new KalmanFilter(0.01, 0.5, 1, 0);
    const kalmanZ = new KalmanFilter(0.01, 0.5, 1, 9.81);
    
    // Improved Rep Counter with Sliding Window for Slow Controlled Reps
    class RepCounter {
      constructor() {
        this.repCount = 0;
        
        // Sliding window parameters (optimized for fast response)
        this.windowDuration = 1.5; // 1.5 second window for faster detection
        this.windowOverlap = 0.8; // 80% overlap - process almost every sample
        this.samplingRate = 20; // 20Hz
        this.windowSamples = Math.floor(this.windowDuration * this.samplingRate);
        this.stepSize = Math.floor(this.windowSamples * (1 - this.windowOverlap));
        
        // Data buffers
        this.accelBuffer = [];
        this.timeBuffer = [];
        this.allSamples = [];
        
        // Rep segmentation
        this.reps = []; // Array of rep segments with timestamps
        this.currentRep = null;
        this.lastRepEndTime = 0;
        
        // Peak detection for slow movements (VERY sensitive)
        this.minPeakProminence = 0.15; // Increased to avoid noise
        this.minPeakDistance = 15; // Minimum 0.75s between peaks (20Hz * 0.75) - one rep cycle
        this.minRepDuration = 0.0; // No minimum duration - allow any speed
        this.maxRepDuration = 12.0; // Maximum 12 seconds per rep
        this.adaptiveThreshold = true; // Use adaptive thresholding
        
        // Dynamic threshold
        this.thresholdHigh = 10.5;
        this.thresholdLow = 9.5;
        this.repHeight = 0;
        
        // State tracking
        this.state = 'IDLE';
        this.lastPeakIndex = -1;
        this.lastValleyIndex = -1;
        this.lastDetectedValleyIndex = -1; // Track the last valley used in a rep
        this.lastDetectedPeakIndex = -1;   // Track the last peak used in a rep
        this.inRepPhase = false;
        
        // Statistics
        this.repTimes = [];
        this.repStartTime = 0;
      }
      
      addSample(accelX, accelY, accelZ, gyroX, gyroY, gyroZ, roll, pitch, yaw, accelMag, timestamp) {
        // Store complete sample data - all samples belong to at least rep 1
        const sample = {
          timestamp: timestamp,
          accelX, accelY, accelZ,
          gyroX, gyroY, gyroZ,
          roll, pitch, yaw,
          accelMag: accelMag,
          repNumber: Math.max(1, this.repCount + 1) // Current rep being performed (starts at 1)
        };
        
        this.allSamples.push(sample);
        this.accelBuffer.push(accelMag);
        this.timeBuffer.push(timestamp);
        
        // Process window immediately when we have enough samples
        if (this.accelBuffer.length >= this.windowSamples) {
          this.processWindow();
        }
      }
      
      processWindow() {
        // Get current window
        const window = this.accelBuffer.slice(-this.windowSamples);
        const windowTimes = this.timeBuffer.slice(-this.windowSamples);
        
        // Calculate statistics EVERY time to prevent threshold drift
        const max = Math.max(...window);
        const min = Math.min(...window);
        const mean = window.reduce((a, b) => a + b, 0) / window.length;
        const range = max - min;
        
        // Calculate standard deviation
        const variance = window.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / window.length;
        const stdDev = Math.sqrt(variance);
        
        // Fixed threshold approach - use minimum threshold to prevent issues with many reps
        // Use 20% of range OR 0.2 m/s¬≤ minimum (more conservative to avoid false positives)
        const rangeThreshold = Math.max(range * 0.20, 0.20);
        const stdThreshold = Math.max(stdDev * 0.6, 0.20);
        const finalThreshold = Math.min(rangeThreshold, stdThreshold);
        
        // Update thresholds EVERY window
        this.thresholdHigh = mean + finalThreshold;
        this.thresholdLow = mean - finalThreshold;
        this.repHeight = range;
        
        // Detect peaks and valleys using prominence-based method
        this.detectRepsInWindow(window, windowTimes);
      }
      
      detectRepsInWindow(window, windowTimes) {
        const n = window.length;
        const currentGlobalIndex = this.accelBuffer.length - 1;
        
        // Find all peaks (local maxima) - 3-sample window for stable detection
        const peaks = [];
        for (let i = 3; i < n - 3; i++) {
          let isPeak = true;
          const centerValue = window[i];
          
          // Check if it's higher than neighbors (3-sample window = stable detection)
          for (let j = i - 3; j <= i + 3; j++) {
            if (j !== i && window[j] >= centerValue) {
              isPeak = false;
              break;
            }
          }
          
          if (isPeak && centerValue > this.thresholdHigh) {
            const globalIndex = currentGlobalIndex - (n - 1 - i);
            
            // Check minimum peak distance to prevent multiple detections in one rep
            if (this.lastPeakIndex === -1 || globalIndex - this.lastPeakIndex >= this.minPeakDistance) {
              peaks.push({
                index: globalIndex,
                value: centerValue,
                time: windowTimes[i]
              });
            }
          }
        }
        
        // Find all valleys (local minima) - 3-sample window for stable detection
        const valleys = [];
        for (let i = 3; i < n - 3; i++) {
          let isValley = true;
          const centerValue = window[i];
          
          // Check if it's lower than neighbors (3-sample window = stable detection)
          for (let j = i - 3; j <= i + 3; j++) {
            if (j !== i && window[j] <= centerValue) {
              isValley = false;
              break;
            }
          }
          
          if (isValley && centerValue < this.thresholdLow) {
            const globalIndex = currentGlobalIndex - (n - 1 - i);
            
            // Check minimum valley distance to prevent multiple detections in one rep
            if (this.lastValleyIndex === -1 || globalIndex - this.lastValleyIndex >= this.minPeakDistance) {
              valleys.push({
                index: globalIndex,
                value: centerValue,
                time: windowTimes[i]
              });
            } 
          }
        }
        
        // Detect rep completion: valley -> peak pattern (1 rep = one cycle)
        // Simple: just need one valley and one peak to count as a rep
        if (valleys.length >= 1 && peaks.length >= 1) {
          const lastValley = valleys[valleys.length - 1];
          const lastPeak = peaks[peaks.length - 1];
          
          // Determine which came first to decide the direction
          let isValidRep = false;
          let startPoint, endPoint, prominence, repDuration;
          
          // Case 1: Valley -> Peak (lifting up from bottom)
          if (lastValley.index < lastPeak.index) {
            // Skip if we've already counted this peak
            if (lastPeak.index <= this.lastDetectedPeakIndex) {
              return;
            }
            
            startPoint = lastValley;
            endPoint = lastPeak;
            prominence = Math.abs(lastPeak.value - lastValley.value);
            repDuration = (lastPeak.time - lastValley.time) / 1000;
            isValidRep = true;
          }
          // Case 2: Peak -> Valley (lowering down from top)
          else if (lastPeak.index < lastValley.index) {
            // Skip if we've already counted this valley
            if (lastValley.index <= this.lastDetectedValleyIndex) {
              return;
            }
            
            startPoint = lastPeak;
            endPoint = lastValley;
            prominence = Math.abs(lastPeak.value - lastValley.value);
            repDuration = (lastValley.time - lastPeak.time) / 1000;
            isValidRep = true;
          }
          
          if (isValidRep) {
            // Log detection attempt for debugging
            console.log(`üîç Rep candidate: duration=${repDuration.toFixed(2)}s, prominence=${prominence.toFixed(3)} m/s¬≤`);
            
            // Very relaxed validation - catch almost all movements
            if (repDuration >= this.minRepDuration && 
                repDuration <= this.maxRepDuration && 
                prominence >= this.minPeakProminence) {
              
              // Count the rep
              this.completeRep(startPoint, lastPeak, endPoint);
              
              // Mark these indices as used
              this.lastDetectedValleyIndex = lastValley.index;
              this.lastDetectedPeakIndex = lastPeak.index;
              this.lastValleyIndex = lastValley.index;
              this.lastPeakIndex = lastPeak.index;
              this.lastRepEndTime = endPoint.time;
            } else {
              console.log(`‚ùå Failed validation: duration=${repDuration >= this.minRepDuration && repDuration <= this.maxRepDuration}, prominence=${prominence >= this.minPeakProminence} (need ${this.minPeakProminence})`);
            }
          }
        }
        
        // Track rep phase for real-time labeling
        if (valleys.length > 0 && peaks.length === 0) {
          this.inRepPhase = true;
          this.state = 'STARTING'; // Bottom position (valley)
        } else if (peaks.length > 0) {
          this.state = 'LIFTING'; // Moving up to peak or coming down
        } else {
          this.inRepPhase = false;
          this.state = 'REST';
        }
      }
      
      completeRep(startValley, peak, endValley) {
        this.repCount++;
        const duration = (endValley.time - startValley.time) / 1000;
        
        console.log(`‚úÖ REP #${this.repCount} | Duration: ${duration.toFixed(2)}s | Range: ${Math.abs(peak.value - startValley.value).toFixed(2)} m/s¬≤`);
        
        // Store rep metadata
        this.reps.push({
          repNumber: this.repCount,
          startTime: startValley.time,
          endTime: endValley.time,
          duration: duration,
          peakValue: peak.value,
          valleyValue: startValley.value,
          range: Math.abs(peak.value - startValley.value)
        });
        
        this.repTimes.push(duration);
        
        // Update all previous samples with this rep number (going backwards from now)
        // All samples up to this point belong to the rep that just completed
        for (let i = this.allSamples.length - 1; i >= 0; i--) {
          const sample = this.allSamples[i];
          // Update samples that are still labeled with the old rep count
          if (sample.repNumber === this.repCount) {
            sample.repNumber = this.repCount;
          } else {
            // Stop when we hit samples from previous reps
            break;
          }
        }
        
        // Visual feedback
        document.getElementById('rep-status').textContent = `Rep #${this.repCount}`;
        document.getElementById('rep-status').className = 'status detecting';
        
        setTimeout(() => {
          document.getElementById('rep-status').textContent = 'Recording...';
        }, 300);
      }
      
      getAverageRepTime() {
        if (this.repTimes.length === 0) return 0;
        return this.repTimes.reduce((a, b) => a + b, 0) / this.repTimes.length;
      }
      
      reset() {
        this.repCount = 0;
        this.accelBuffer = [];
        this.timeBuffer = [];
        this.allSamples = [];
        this.reps = [];
        this.currentRep = null;
        this.lastRepEndTime = 0;
        this.repTimes = [];
        this.state = 'IDLE';
        this.lastPeakIndex = -1;
        this.lastValleyIndex = -1;
        this.lastDetectedValleyIndex = -1;
        this.lastDetectedPeakIndex = -1;
        this.inRepPhase = false;
        this.repStartTime = 0;
      }
    }
    
    const repCounter = new RepCounter();
    
    // Sample counting for data rate calculation
    let sampleCount = 0;
    let lastSampleTime = Date.now();
    let dataRate = 0;
    
    // Initialize Chart
    function initChart() {
      const ctx = document.getElementById('accelChart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: timeData,
          datasets: [
            {
              label: 'Raw Acceleration Magnitude',
              data: accelMagData,
              borderColor: 'rgba(255, 99, 132, 0.5)',
              backgroundColor: 'rgba(255, 99, 132, 0.1)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.1
            },
            {
              label: 'Filtered Acceleration (Kalman)',
              data: accelMagFilteredData,
              borderColor: 'rgba(54, 162, 235, 1)',
              backgroundColor: 'rgba(54, 162, 235, 0.1)',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.1
            },
            {
              label: 'High Threshold (Peak)',
              data: Array(MAX_CHART_POINTS).fill(repCounter.thresholdHigh),
              borderColor: 'rgba(75, 192, 192, 0.5)',
              borderWidth: 1,
              borderDash: [5, 5],
              pointRadius: 0,
              fill: false
            },
            {
              label: 'Low Threshold (Trough)',
              data: Array(MAX_CHART_POINTS).fill(repCounter.thresholdLow),
              borderColor: 'rgba(255, 159, 64, 0.5)',
              borderWidth: 1,
              borderDash: [5, 5],
              pointRadius: 0,
              fill: false
            }
          ]
        },
        options: {
          responsive: true,
          animation: false,
          scales: {
            x: {
              display: true,
              title: {
                display: true,
                text: 'Time (seconds)'
              }
            },
            y: {
              display: true,
              title: {
                display: true,
                text: 'Acceleration (m/s¬≤)'
              },
              min: 8,
              max: 12
            }
          },
          plugins: {
            legend: {
              display: true,
              position: 'top'
            }
          }
        }
      });
    }
    
    // Update chart with new data
    function updateChart() {
      if (chart) {
        chart.data.datasets[2].data = Array(timeData.length).fill(repCounter.thresholdHigh);
        chart.data.datasets[3].data = Array(timeData.length).fill(repCounter.thresholdLow);
        chart.update('none'); // 'none' mode for performance
      }
    }

    async function connectToBLE() {
      try {
        console.log('Requesting Bluetooth Device...');
        device = await navigator.bluetooth.requestDevice({
          filters: [{ name: 'AppLift_IMU' }],
          optionalServices: [SERVICE_UUID]
        });

        console.log('Connecting to GATT Server...');
        const server = await device.gatt.connect();

        console.log('Getting Service...');
        const service = await server.getPrimaryService(SERVICE_UUID);

        console.log('Getting Characteristic...');
        characteristic = await service.getCharacteristic(CHARACTERISTIC_UUID_IMU);

        console.log('Starting Notifications...');
        await characteristic.startNotifications();

        characteristic.addEventListener('characteristicvaluechanged', handleIMUData);
        
        // Get NFC equipment characteristic
        try {
          const nfcCharacteristic = await service.getCharacteristic('ceb5483e-36e1-4688-b7f5-ea07361b26a8');
          await nfcCharacteristic.startNotifications();
          nfcCharacteristic.addEventListener('characteristicvaluechanged', handleNFCData);
          console.log('NFC equipment characteristic subscribed!');
        } catch (e) {
          console.warn('NFC characteristic not available:', e);
        }
        
        console.log('Connected! Receiving IMU data...');
        document.getElementById('connection-status').textContent = 'Connected';
        document.getElementById('connection-status').style.color = '#28a745';
        alert('Connected to AppLift_IMU successfully! Press "Start Recording" to begin.');
        
        // Initialize chart if not already done
        if (!chart) {
          initChart();
        }
      } catch (error) {
        console.error('Connection failed:', error);
        document.getElementById('connection-status').textContent = 'Failed';
        document.getElementById('connection-status').style.color = '#dc3545';
        alert('Connection failed: ' + error.message);
      }
    }

    function handleIMUData(event) {
      const value = event.target.value;
      
      // Parse the 40-byte data array
      const dataView = new DataView(value.buffer);
      
      const imuData = {
        accelX: dataView.getFloat32(0, true),
        accelY: dataView.getFloat32(4, true),
        accelZ: dataView.getFloat32(8, true),
        gyroX: dataView.getFloat32(12, true),
        gyroY: dataView.getFloat32(16, true),
        gyroZ: dataView.getFloat32(20, true),
        roll: dataView.getFloat32(24, true),
        pitch: dataView.getFloat32(28, true),
        yaw: dataView.getFloat32(32, true),
        timestamp: dataView.getUint32(36, true)
      };
      
      // Calculate acceleration magnitude
      const accelMag = Math.sqrt(
        imuData.accelX * imuData.accelX +
        imuData.accelY * imuData.accelY +
        imuData.accelZ * imuData.accelZ
      );
      
      // Apply Kalman filter to each axis
      const filteredX = kalmanX.update(imuData.accelX);
      const filteredY = kalmanY.update(imuData.accelY);
      const filteredZ = kalmanZ.update(imuData.accelZ);
      
      // Calculate filtered magnitude
      const filteredMag = Math.sqrt(
        filteredX * filteredX +
        filteredY * filteredY +
        filteredZ * filteredZ
      );
      
      // Only process if recording (after countdown)
      if (isRecording && !countdownActive) {
        // Set recording start time on first sample
        if (recordingStartTime === 0) {
          recordingStartTime = imuData.timestamp;
          console.log(`üìç Recording started at timestamp: ${recordingStartTime}`);
        }
        
        // Calculate relative timestamp (milliseconds from start)
        const relativeTime = imuData.timestamp - recordingStartTime;
        
        // Log raw data for CSV export
        rawDataLog.push({
          timestamp: relativeTime,
          accelX: imuData.accelX,
          accelY: imuData.accelY,
          accelZ: imuData.accelZ,
          gyroX: imuData.gyroX,
          gyroY: imuData.gyroY,
          gyroZ: imuData.gyroZ,
          roll: imuData.roll,
          pitch: imuData.pitch,
          yaw: imuData.yaw,
          accelMag: accelMag,
          filteredX: filteredX,
          filteredY: filteredY,
          filteredZ: filteredZ,
          filteredMag: filteredMag
        });
        
        // Update chart data with relative time in seconds.milliseconds format
        const seconds = Math.floor(relativeTime / 1000);
        const milliseconds = relativeTime % 1000;
        const displayTime = `${seconds}.${milliseconds.toString().padStart(3, '0')}`;
        timeData.push(displayTime);
        accelMagData.push(accelMag);
        accelMagFilteredData.push(filteredMag);
        
        // Keep buffer size manageable
        if (timeData.length > MAX_CHART_POINTS) {
          timeData.shift();
          accelMagData.shift();
          accelMagFilteredData.shift();
        }
        
        // Update chart
        updateChart();
        
        // Rep counting with all sensor data
        repCounter.addSample(
          imuData.accelX, imuData.accelY, imuData.accelZ,
          imuData.gyroX, imuData.gyroY, imuData.gyroZ,
          imuData.roll, imuData.pitch, imuData.yaw,
          filteredMag, relativeTime
        );
        updateRepStats();
      }
      
      // Always update display (even when not recording)
      displayIMUData(imuData, accelMag, filteredX, filteredY, filteredZ, filteredMag);
      
      // Update sample count and data rate
      sampleCount++;
      const now = Date.now();
      if (now - lastSampleTime >= 1000) {
        dataRate = sampleCount;
        sampleCount = 0;
        lastSampleTime = now;
        document.getElementById('data-rate').textContent = dataRate;
      }
      document.getElementById('sample-count').textContent = sampleCount + dataRate * Math.floor((now - lastSampleTime) / 1000);
    }

    function handleNFCData(event) {
      const value = event.target.value;
      const dataView = new DataView(value.buffer);
      
      // First byte is the length
      const length = dataView.getUint8(0);
      
      // Extract equipment name (remaining bytes)
      let equipmentName = '';
      for (let i = 1; i <= length && i < value.byteLength; i++) {
        equipmentName += String.fromCharCode(dataView.getUint8(i));
      }
      
      console.log('üì° NFC Equipment detected via BLE:', equipmentName);
      
      // Update UI
      document.getElementById('nfc-equipment').textContent = equipmentName;
      const now = new Date();
      document.getElementById('nfc-timestamp').textContent = now.toLocaleTimeString();
      
      // Display NFC equipment notification
      showNFCNotification(equipmentName);
    }

    function showNFCNotification(equipmentName) {
      // Create notification element
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px 30px;
        border-radius: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        font-size: 18px;
        font-weight: bold;
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
      `;
      
      notification.textContent = `üì± Equipment: ${equipmentName}`;
      
      // Add animation styles
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from {
            transform: translateX(400px);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
        @keyframes slideOut {
          from {
            transform: translateX(0);
            opacity: 1;
          }
          to {
            transform: translateX(400px);
            opacity: 0;
          }
        }
      `;
      document.head.appendChild(style);
      
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds with fade out
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-in forwards';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }

    function displayIMUData(data, accelMag, filteredX, filteredY, filteredZ, filteredMag) {
      // Update raw data
      document.getElementById('accel-x').textContent = data.accelX.toFixed(2);
      document.getElementById('accel-y').textContent = data.accelY.toFixed(2);
      document.getElementById('accel-z').textContent = data.accelZ.toFixed(2);
      document.getElementById('accel-mag').textContent = accelMag.toFixed(2);
      
      // Update filtered data
      document.getElementById('accel-x-filtered').textContent = filteredX.toFixed(2);
      document.getElementById('accel-y-filtered').textContent = filteredY.toFixed(2);
      document.getElementById('accel-z-filtered').textContent = filteredZ.toFixed(2);
      document.getElementById('accel-mag-filtered').textContent = filteredMag.toFixed(2);
      
      // Update gyroscope
      document.getElementById('gyro-x').textContent = data.gyroX.toFixed(2);
      document.getElementById('gyro-y').textContent = data.gyroY.toFixed(2);
      document.getElementById('gyro-z').textContent = data.gyroZ.toFixed(2);
      
      // Update orientation
      document.getElementById('roll').textContent = data.roll.toFixed(2);
      document.getElementById('pitch').textContent = data.pitch.toFixed(2);
      document.getElementById('yaw').textContent = data.yaw.toFixed(2);
    }
    
    function updateRepStats() {
      // Update rep count
      document.getElementById('rep-count').textContent = repCounter.repCount;
      
      // Update rep detection state
      document.getElementById('rep-state').textContent = repCounter.state;
      document.getElementById('buffer-state').textContent = `${repCounter.accelBuffer.length}/${repCounter.windowSamples}`;
      
      // Update repHeight info
      if (repCounter.repHeight > 0) {
        document.getElementById('last-peak').textContent = repCounter.repHeight.toFixed(2) + ' m/s¬≤';
      }
      
      // Update dynamic threshold display
      document.getElementById('threshold-high-display').textContent = repCounter.thresholdHigh.toFixed(2) + ' m/s¬≤';
      document.getElementById('threshold-low-display').textContent = repCounter.thresholdLow.toFixed(2) + ' m/s¬≤';
      const range = repCounter.thresholdHigh - repCounter.thresholdLow;
      document.getElementById('threshold-range').textContent = range.toFixed(2) + ' m/s¬≤';
      
      // Update timing stats
      const avgTime = repCounter.getAverageRepTime();
      if (avgTime > 0) {
        document.getElementById('avg-rep-time').textContent = avgTime.toFixed(2);
      }
      if (repCounter.repTimes.length > 0) {
        document.getElementById('last-rep-time').textContent = repCounter.repTimes[repCounter.repTimes.length - 1].toFixed(2);
      }
      
      // Update total time (only when recording)
      if (isRecording && !countdownActive && recordingStartTime > 0) {
        const now = Date.now();
        const totalTime = (now - recordingStartTime - (Date.now() - recordingStartTime)) / 1000;
        if (rawDataLog.length > 0) {
          const lastTimestamp = rawDataLog[rawDataLog.length - 1].timestamp;
          document.getElementById('total-time').textContent = (lastTimestamp / 1000).toFixed(1);
        }
      }
    }
    
    function resetRepCount() {
      repCounter.reset();
      rawDataLog = [];
      recordingStartTime = 0;
      document.getElementById('rep-count').textContent = '0';
      document.getElementById('rep-state').textContent = '--';
      document.getElementById('buffer-state').textContent = '--';
      document.getElementById('last-peak').textContent = '--';
      document.getElementById('threshold-high-display').textContent = '--';
      document.getElementById('threshold-low-display').textContent = '--';
      document.getElementById('threshold-range').textContent = '--';
      document.getElementById('avg-rep-time').textContent = '--';
      document.getElementById('last-rep-time').textContent = '--';
      document.getElementById('total-time').textContent = '--';
      document.getElementById('rep-status').textContent = 'Reset';
      document.getElementById('rep-status').className = 'status idle';
      console.log('üîÑ Rep counter reset');
    }
    
    async function showCountdown() {
      countdownActive = true;
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        font-size: 120px;
        color: white;
        font-weight: bold;
      `;
      document.body.appendChild(overlay);
      
      for (let i = 3; i > 0; i--) {
        overlay.textContent = i;
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      overlay.textContent = 'GO!';
      await new Promise(resolve => setTimeout(resolve, 500));
      document.body.removeChild(overlay);
      countdownActive = false;
    }
    
    function exportToCSV() {
      if (rawDataLog.length === 0) {
        alert('No data to export!');
        return;
      }
      
      // Create enriched data with proper rep labeling
      const enrichedData = rawDataLog.map((logEntry, index) => {
        // Get rep number from allSamples (which tracks rep assignment in real-time)
        const sample = repCounter.allSamples[index];
        const repNumber = sample ? sample.repNumber : 1; // Default to rep 1 if not found
        
        // Format timestamp as seconds.milliseconds (e.g., 00.000, 01.523, 12.045)
        const seconds = Math.floor(logEntry.timestamp / 1000);
        const milliseconds = logEntry.timestamp % 1000;
        const formattedTime = `${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(3, '0')}`;
        
        return {
          rep: repNumber,
          timestamp: formattedTime,
          timestamp_ms: logEntry.timestamp,
          accelX: logEntry.accelX.toFixed(4),
          accelY: logEntry.accelY.toFixed(4),
          accelZ: logEntry.accelZ.toFixed(4),
          accelMag: logEntry.accelMag.toFixed(4),
          gyroX: logEntry.gyroX.toFixed(4),
          gyroY: logEntry.gyroY.toFixed(4),
          gyroZ: logEntry.gyroZ.toFixed(4),
          roll: logEntry.roll.toFixed(2),
          pitch: logEntry.pitch.toFixed(2),
          yaw: logEntry.yaw.toFixed(2),
          filteredX: logEntry.filteredX.toFixed(4),
          filteredY: logEntry.filteredY.toFixed(4),
          filteredZ: logEntry.filteredZ.toFixed(4),
          filteredMag: logEntry.filteredMag.toFixed(4)
        };
      });
      
      // Create CSV header
      const headers = Object.keys(enrichedData[0]);
      let csvContent = headers.join(',') + '\n';
      
      // Add data rows
      enrichedData.forEach(row => {
        csvContent += Object.values(row).join(',') + '\n';
      });
      
      // Create download link
      const blob = new Blob([csvContent], { type: 'text/csv' });
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `applift_workout_${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      window.URL.revokeObjectURL(url);
      
      console.log(`üìä Exported ${enrichedData.length} samples (${repCounter.repCount} reps) to CSV`);
      alert(`Exported ${enrichedData.length} samples with ${repCounter.repCount} reps!`);
    }
    
    function showExportModal() {
      return new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.7);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 9999;
        `;
        
        const modal = document.createElement('div');
        modal.style.cssText = `
          background: white;
          padding: 30px;
          border-radius: 10px;
          box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          text-align: center;
          max-width: 400px;
        `;
        
        modal.innerHTML = `
          <h2 style="margin-top: 0; color: #333;">Recording Stopped</h2>
          <p style="color: #666; margin: 20px 0;">
            You recorded <strong>${repCounter.repCount} reps</strong> with <strong>${rawDataLog.length} samples</strong>.
          </p>
          <p style="color: #666; margin: 20px 0;">
            Would you like to download the CSV file?
          </p>
          <div style="display: flex; gap: 10px; justify-content: center; margin-top: 25px;">
            <button id="modal-download" style="
              padding: 12px 24px;
              font-size: 16px;
              background-color: #28a745;
              color: white;
              border: none;
              border-radius: 5px;
              cursor: pointer;
              font-weight: bold;
            ">Download CSV</button>
            <button id="modal-skip" style="
              padding: 12px 24px;
              font-size: 16px;
              background-color: #6c757d;
              color: white;
              border: none;
              border-radius: 5px;
              cursor: pointer;
            ">Skip</button>
          </div>
        `;
        
        overlay.appendChild(modal);
        document.body.appendChild(overlay);
        
        document.getElementById('modal-download').addEventListener('click', () => {
          document.body.removeChild(overlay);
          resolve(true);
        });
        
        document.getElementById('modal-skip').addEventListener('click', () => {
          document.body.removeChild(overlay);
          resolve(false);
        });
      });
    }
    
    async function toggleRecording() {
      if (!isRecording) {
        // Starting recording - show countdown first
        const button = document.querySelector('button[onclick="toggleRecording()"]');
        button.disabled = true;
        button.textContent = 'Starting...';
        
        await showCountdown();
        
        // Now start actual recording
        isRecording = true;
        recordingStartTime = 0; // Will be set on first sample
        rawDataLog = [];
        repCounter.reset();
        
        button.disabled = false;
        button.textContent = 'Stop Recording';
        button.style.backgroundColor = '#dc3545';
        document.getElementById('rep-status').textContent = 'Recording...';
        document.getElementById('rep-status').className = 'status detecting';
        console.log('üî¥ Recording started after countdown');
      } else {
        // Stop recording
        isRecording = false;
        const button = document.querySelector('button[onclick="toggleRecording()"]');
        button.textContent = 'Start Recording';
        button.style.backgroundColor = '#007bff';
        document.getElementById('rep-status').textContent = 'Stopped';
        document.getElementById('rep-status').className = 'status idle';
        console.log('‚èπÔ∏è Recording stopped');
        
        // Show modal to confirm CSV export
        if (rawDataLog.length > 0) {
          const shouldExport = await showExportModal();
          if (shouldExport) {
            exportToCSV();
          } else {
            console.log('üìä CSV export skipped by user');
          }
        }
      }
    }
    
    // Initialize chart on page load
    window.onload = function() {
      initChart();
    };
  </script>
</body>
</html>